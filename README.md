# 방문 요양 고객관리 ERP OnCare

<p align="center">
  <img width="1430" height="806" alt="image" src="https://github.com/user-attachments/assets/a25e540e-3fb5-4edd-bf2d-053bef1073f0" />
</p>


<h1>현장 중심의 요양 서비스 운영을 위한 올인원 관리 솔루션</h1>

> 수급자, 요양보호사, 방문 일정, 직원, 용품, 업무 현황을 하나의 시스템에서 통합 관리할 수 있는 방문 요양 전용 ERP입니다.<br/>
현장의 실제 업무 흐름을 기반으로 설계되어, 반복적인 행정 업무를 줄이고 운영 효율을 높이며 안정적인 요양 서비스 제공을 지원합니다.

---

## 😊 조원 소개

<table style="width:100%;">
  <thead>
    <tr align="center">
      <th>팀원</th>
      <th>팀원</th>
      <th>팀원</th>
      <th>팀원</th>
      <th>팀원</th>
      <th>팀원</th>        
    </tr>
  </thead>
  <tbody>
    <tr align="center">
      <td>
        <a href="https://github.com/kjin0204" target="_blank">
          <img src="https://github.com/Ace-Time/be19-final-A-Team/blob/main/img/%EA%B0%9C%EC%9D%B8%EC%9D%B4%EB%AF%B8%EC%A7%80/%EA%B0%95%ED%98%95%EA%B7%9C.png" width="210" style="border-radius:100%" alt="강형규"/><br/>
          <b>강형규</b>
        </a>
      </td>
      <td>
        <a href="https://github.com/Yunji458" target="_blank">
          <img src="https://github.com/Ace-Time/be19-final-A-Team/blob/main/img/%EA%B0%9C%EC%9D%B8%EC%9D%B4%EB%AF%B8%EC%A7%80/%EA%B9%80%EC%9C%A4%EC%A7%80.png" width="210" style="border-radius:100%" alt="김윤지"/><br/>
          <b>김윤지</b>
        </a>
      </td>
      <td>
        <a href="https://github.com/woo-kyoung-nam" target="_blank">
          <img src="https://github.com/Ace-Time/be19-final-A-Team/blob/main/img/%EA%B0%9C%EC%9D%B8%EC%9D%B4%EB%AF%B8%EC%A7%80/%EB%82%A8%EC%9A%B0%EA%B2%BD.png" width="210" style="border-radius:100%" alt="남우경"/><br/>
          <b>남우경</b>
        </a>
      </td>
      <td>
        <a href="https://github.com/seoguhoe2" target="_blank">
          <img src="https://github.com/Ace-Time/be19-final-A-Team/blob/main/img/%EA%B0%9C%EC%9D%B8%EC%9D%B4%EB%AF%B8%EC%A7%80/%EB%B0%B1%EC%A4%80%EC%8A%B9.png" width="210" style="border-radius:100%" alt="백준승"/><br/>
          <b>백준승</b>
        </a>
      </td>
      <td>
        <a href="https://github.com/leejaeguen" target="_blank">
          <img src="https://github.com/Ace-Time/be19-final-A-Team/blob/main/img/%EA%B0%9C%EC%9D%B8%EC%9D%B4%EB%AF%B8%EC%A7%80/%EC%9D%B4%EC%9E%AC%EA%B7%BC.png" width="210" style="border-radius:100%" alt="이재근"/><br/>
          <b>이재근</b>
        </a>
      </td>
      <td>
        <a href="https://github.com/golealda" target="_blank">
          <img src="https://github.com/Ace-Time/be19-final-A-Team/blob/main/img/%EA%B0%9C%EC%9D%B8%EC%9D%B4%EB%AF%B8%EC%A7%80/%EC%9D%B4%ED%98%84%EC%88%98.png" width="210" style="border-radius:100%" alt="이현수"/><br/>
          <b>이현수</b>
        </a>
      </td>
    </tr>
  </tbody>
</table>

---

**📜 목차**

[**💡 Tech Stack**](#-Tech-Stack)

[**📌 프로젝트 수립 배경**](#-프로젝트-수립-배경)

[**📊 사용자 설문 조사 및 피드백**](#-사용자-설문-조사-및-피드백)

[**📢 프로젝트 설명**](#-프로젝트-설명)

[**🛠️ 주요 기능**](#️-주요-기능)

[**📄 WBS**](#-WBS)

[**🙆‍♀️ 요구사항 명세서**](#️-요구사항-명세서)

[**💭 DDD 설계**](#-DDD-설계)

[**🗃️ DB 모델링**](#️-DB-모델링)

[**🪄 Figma**](#-FIGMA)

[**🛜 CI/CD 프로젝트 아키텍처**](#-CICD-프로젝트-아키텍처)

[**🚩 젠킨스 파이프라인 파일 스크립트 코드**](#-젠킨스-파이프라인-파일-스크립트-코드)

[**📱 CI/CD 테스트**](#-CICD-테스트)

[**🍪 개인 회고록**](#-개인-회고록)

---

## 💡 Tech Stack
### 🌿 Backend
![Spring](https://img.shields.io/badge/Spring-6DB33F?style=for-the-badge&logo=spring&logoColor=white)
![Spring Boot](https://img.shields.io/badge/Spring_Boot-6DB33F?style=for-the-badge&logo=springboot&logoColor=white)
![Spring Security](https://img.shields.io/badge/Spring_Security-6DB33F?style=for-the-badge&logo=springsecurity&logoColor=white)
![Spring Data JPA](https://img.shields.io/badge/Spring_Data_JPA-6DB33F?style=for-the-badge)
![Gradle](https://img.shields.io/badge/Gradle-02303A?style=for-the-badge&logo=gradle&logoColor=white)
![JWT](https://img.shields.io/badge/JWT-000000?style=for-the-badge&logo=JSON%20web%20tokens&logoColor=white)
![Hibernate](https://img.shields.io/badge/Hibernate-59666C?style=for-the-badge&logo=hibernate&logoColor=white)
![Docker](https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=docker&logoColor=white)
![Python](https://img.shields.io/badge/PYTHON-blue?style=for-the-badge&logo=python&logoColor=white)

### 🌿 Frontend
![Vue.js](https://img.shields.io/badge/Vue.js-4FC08D?style=for-the-badge&logo=vue.js&logoColor=white)
![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black)
![HTML5](https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=html5&logoColor=white)
![CSS3](https://img.shields.io/badge/CSS3-1572B6?style=for-the-badge&logo=css3&logoColor=white)
![Axios](https://img.shields.io/badge/Axios-5A29E4?style=for-the-badge)
![Vue Router](https://img.shields.io/badge/Vue_Router-4FC08D?style=for-the-badge)
![Vuetify](https://img.shields.io/badge/Vuetify-1867C0?style=for-the-badge)

### 🗃️ Database
![MariaDB](https://img.shields.io/badge/MariaDB-003545?style=for-the-badge&logo=mariadb&logoColor=white)
![Redis](https://img.shields.io/badge/Redis-DC382D?style=for-the-badge&logo=redis&logoColor=white)

### 🛠️ Tools
![Git](https://img.shields.io/badge/Git-F05032?style=for-the-badge&logo=git&logoColor=white)
![GitHub](https://img.shields.io/badge/GitHub-181717?style=for-the-badge&logo=github&logoColor=white)
![Figma](https://img.shields.io/badge/Figma-F24E1E?style=for-the-badge&logo=figma&logoColor=white)
![Discord](https://img.shields.io/badge/Discord-5865F2?style=for-the-badge&logo=discord&logoColor=white)
![Postman](https://img.shields.io/badge/Postman-FF6C37?style=for-the-badge&logo=postman&logoColor=white)

### 🏗️ Infrastructure
![AWS](https://img.shields.io/badge/AWS-232F3E?style=for-the-badge&logo=amazonaws&logoColor=white)
![MySQL](https://img.shields.io/badge/SQL-4479A1?style=for-the-badge&logo=mysql&logoColor=white)
![Redis](https://img.shields.io/badge/Redis-DC382D?style=for-the-badge&logo=redis&logoColor=white)
![Prometheus](https://img.shields.io/badge/Prometheus-E6522C?style=for-the-badge&logo=prometheus&logoColor=white)
![Grafana](https://img.shields.io/badge/Grafana-F46800?style=for-the-badge&logo=grafana&logoColor=white)
![Grafana Loki](https://img.shields.io/badge/Grafana_Loki-F46800?style=for-the-badge&logo=grafana&logoColor=white)

---

## 📌 프로젝트 수립 배경

대한민국은 초고령사회로 진입하며 노인 인구가 빠르게 증가하고 있고, 이에 따라 요양 서비스 수요 또한 지속적으로 확대되고 있습니다.  
그러나 요양 시설의 수용 인원은 한계가 있어, 재가 요양(방문 요양)이 주요 대안으로 제시되고 있으며 정부 역시 재가 요양 서비스 확대 정책을 추진하고 있습니다.

이와 함께 관리해야 할 수급자와 요양보호사 인원이 증가하면서, 방문 요양 기관의 운영 효율을 높이기 위한 **전용 ERP 시스템의 필요성**이 점점 커지고 있습니다.  
하지만 실제 현장에서 사용되는 기존 ERP 시스템은 사용자 환경과 업무 흐름을 충분히 반영하지 못해, 도입 효과가 제한적이라는 문제점이 존재합니다.

이에 본 프로젝트는 **현장 중심의 방문 요양 고객관리 ERP 시스템(OnCare)**을 기획·개발하여, 실제 사용자에게 도움이 되는 실질적인 운영 도구를 제공하는 것을 목표로 시작되었습니다.

---

### 문제 정의

#### 1. 기존 ERP 시스템의 낮은 사용성
- 현장에서 사용 중인 ERP의 UI가 실질 사용자에게 적합하지 않아 사용 빈도가 낮음  
- 그로 인해 ERP 도입 효과가 충분히 발휘되지 못하는 상황 발생

#### 2. 요양보호사를 고려하지 않은 기능 구성
- 실제 주요 사용자인 요양보호사에게 필요한 기능이 부족
- 비교적 높은 연령대의 요양보호사들에게 ERP 사용 자체가 어렵고 부담으로 작용

#### 3. 고객 맞춤 관리의 한계
- 수급자 개개인의 병력, 위험 요소, 특이사항 등을 체계적으로 관리하기 어려움
- 기존 시스템에서는 고객별 맞춤 관리가 구조적으로 제한됨

---

### 솔루션 제안

#### 1. 사용자 중심 UI/UX 설계
- 직관적이고 단순한 화면 구성으로 고령 종사자도 쉽게 사용 가능하도록 개선
- 불필요한 복잡성을 제거하고 핵심 기능 위주로 재구성

#### 2. 요양보호사 맞춤 기능 제공
- 요양 기록 **AI 요약 기능**을 통해 인수인계 및 기록 부담 감소
- 수급자별 위험 등급 제공으로 현장 판단을 돕는 정보 시각화
- 요양보호사의 사용 경험 개선을 통해 서비스 품질 향상

#### 3. 고객 맞춤형 관리 시스템 구축
- 수급자별 특이사항, 병력, 위험 요소를 체계적으로 관리
- 개인 맞춤 관리 기반으로 서비스 만족도 향상 및 이탈 방지
- 체계적인 고객 관리를 통해 잠재 고객 유치 기반 마련

---

### 현장 설문 조사 결과

본 프로젝트는 **현재 근무 중인 요양보호사 20명을 대상으로 한 설문 조사**를 바탕으로 기획되었습니다.

**Q1. 현재 사용 중인 ERP에 대해 불편함을 느끼고 계신가요?**
- 불편함을 느낀다: **12명**
- 잘 모르겠다: 2명
- 편하게 사용하고 있다: 6명

**Q2. ERP 사용 시 가장 개선이 필요하다고 느끼는 부분은 무엇인가요?**
- 기능 부족: **8명**
- UI 개선 필요: **11명**
- 기능이 너무 복잡함: 3명

**Q3. ERP 개선에 대한 자유 의견**

> “상담 업무를 병행하는 경우가 많은데 관련 기능이 없어 불편했다.”  
> “화면이 너무 복잡해서 보기에도 이쁘지 않고 사용하기 힘들다.”  
> “특정 기능을 직관적으로 찾기 어려워 따로 ERP를 공부해야 하는 느낌이었다.”

## 📊 사용자 설문 조사 및 피드백

본 설문 조사는 **OnCare 서비스 기획 및 기능 개선을 위해 실제 요양보호사 및 관계자를 대상으로 진행**되었습니다.

---

### Q1. OnCare에서 가장 도움이 될 것 같은 기능은 무엇인가요?

- 일정 관리: 1명  
- 직원 관리: **4명**  
- 수급자 관리: 2명  
- 고객 관리: **7명**  
- 용품 관리: 2명  
- 업무 관리: 0명  
- 요양보호사 페이지: **4명**

👉 **고객 관리, 직원 관리, 요양보호사 페이지**에 대한 기대가 가장 높게 나타났습니다.

---

### Q2. OnCare에서 가장 개선이 필요하다고 느낀 부분은 무엇인가요?

- 일정 관리: 0명  
- 직원 관리: **7명**  
- 수급자 관리: 1명  
- 고객 관리: 2명  
- 용품 관리: 0명  
- 업무 관리: **9명**  
- 요양보호사 페이지: 1명  

👉 **업무 관리와 직원 관리 영역의 개선 요구가 가장 높았습니다.**

---

### Q3. OnCare에 대한 자유 의견

> “실제 사용하려면 공단 시스템과 연계돼야 하는데, 그 부분이 없어 아쉬웠다.”  
> “수급자에서 위험 등급이 산정되는 게 알아보기 좋고, AI 요약 기능도 신기했다.”  
> “가입을 안 한 고객에 대해 상담 대처가 쉬워질 것 같아 신선하고 좋았다.”

---

### 설문 결과 요약

- **고객 관리 기능에 대한 기대가 가장 높았으며**,  
  이는 기존 ERP에서 다루기 어려웠던 잠재 고객 관리, 상담 흐름 관리에 대한 니즈가 크다는 것을 보여줍니다.
- **업무 관리와 직원 관리 영역의 개선 요구가 높아**,  
  현장에서 실제로 체감하는 업무 피로도가 이 영역에 집중되어 있음을 확인할 수 있었습니다.
- AI 요약, 위험 등급 시각화 등 **OnCare의 차별화 기능에 대한 긍정적 반응**도 확인되었습니다.

---

## 📢 프로젝트 설명

### 1. 프로젝트 주제

**방문 요양 고객관리 ERP 시스템 – OnCare**

---

### 2. 프로젝트 개요

OnCare는 방문 요양 기관의 운영 효율을 높이기 위해 기획·개발된 **현장 중심 요양 고객관리 ERP 시스템**입니다.  
수급자 관리, 요양보호사 관리, 일정 배정, 매칭, 근무 기록, 물품 관리 등  
방문 요양 운영에 필요한 모든 기능을 하나의 시스템에서 통합 관리할 수 있도록 설계되었습니다.

기존 요양 ERP의 낮은 사용성과 복잡한 UI, 현장 흐름과 맞지 않는 기능 구성 문제를 해결하기 위해  
**실제 요양보호사 인터뷰 및 설문 조사 결과를 기반으로 기획**되었으며,  
고령 종사자도 쉽게 사용할 수 있는 직관적인 UI와 실무 중심 기능 제공을 목표로 합니다.

또한 고객(수급자) 개개인의 병력, 위험 요소, 특이사항을 체계적으로 관리하고,  
요양 기록 AI 요약, 위험 등급 시각화, 맞춤 매칭 기능 등을 통해  
**요양보호사의 업무 부담을 줄이고 서비스 품질을 향상시키는 것**을 핵심 목표로 합니다.

---

## 🛠️ 주요 기능

### 1. 직원 관리

- 직원 개개인의 **전자 결재 기능**
- 자격증 만료 알림 및 관리 기능
- 직원 정보, 근무 상태, 이력 관리 기능 제공

---

### 2. 수급자 관리

- 수급자 정보 통합 관리 (기본 정보, 병력, 특이사항 등)
- **장기 요양 등급 만료 알림, 청구서 수신 알림** 등 다양한 알림 제공
- 수급자 요청에 맞는 **맞춤 요양보호사 추천 매칭 기능**

---

### 3. 요양보호사 관리

- 요양보호사 **일정 관리 및 근무 스케줄 관리**
- 수급자별 **위험 등급 및 위험 요소 정보 제공**
- 요양 기록 **AI 요약 기능 제공**으로 인수인계 및 기록 업무 효율화

---

### 4. 물품 관리

- 렌탈 물품 계약 관리 및 상태 관리
- 물품 히스토리 기반 **예상 이익 분석 및 인사이트 제공**
- 물품 분실, 회수, 교체 이력 관리

---

### 5. 고객 관리

- 가입 상담 시 고객 상태에 따른 **맞춤 정보 제공**
- 이탈 고객에 대한 사유 저장 및 관리
- 고객 정보 변화에 따른 **주기적인 인텐션 분석 및 알림 제공**
- 이탈 징후 감지 후 대응 솔루션 제공

---

## 📄 WBS

🔗 [WBS 바로가기](https://docs.google.com/spreadsheets/d/1_9muPoG2TCygdrsBb2QGj5fwmSjnReSOMnvmmsylSCk/edit?gid=1154634314#gid=1154634314)

---

## 🙆‍♀️ 요구사항 명세서

🔗 [요구사항 명세서 바로가기](https://docs.google.com/spreadsheets/d/1_9muPoG2TCygdrsBb2QGj5fwmSjnReSOMnvmmsylSCk/edit?gid=0#gid=0)

---

## 💭 DDD 설계

**1. Domain Event Storming**

![](https://github.com/Cal-Mate/be19-4th-Cal-Mate-Dev/blob/main/img/DDD/1.png)

![](https://github.com/Cal-Mate/be19-4th-Cal-Mate-Dev/blob/main/img/DDD/2.jpg)

![](https://github.com/Cal-Mate/be19-4th-Cal-Mate-Dev/blob/main/img/DDD/3.png)

---

## 🗃️ DB 모델링

![](https://github.com/Cal-Mate/be19-4th-Cal-Mate-Dev/blob/main/img/ERD/erdcloud.png)

---

## 🪄 Figma

🔗 [Figma 디자인]

![](https://github.com/Cal-Mate/be19-4th-Cal-Mate-Dev/blob/main/img/Figma/Figma.png)

---

## 🛜 CI/CD 프로젝트 아키텍처

![](img/CICD/Architecture.png)

---

## 🚩 젠킨스 파이프라인 파일 스크립트 코드

```
pipeline {
    agent any

    tools {
        gradle 'gradle'
        jdk 'openJDK17'
    }

    environment {
        SOURCE_GITHUB_URL = 'https://github.com/Cal-Mate/CalMate-Backend.git'
        MANIFESTS_GITHUB_URL = 'https://github.com/Cal-Mate/cal-mate-argo.git'
        GIT_USERNAME = 'kjin0204'
        GIT_EMAIL = 'kin0204@naver.com'
    }

    stages {
        stage('Preparation') {
            steps {
                script {
                    if (isUnix()) {
                        sh 'docker --version'
                    } else {
                        bat 'docker --version'
                    }
                }
            }
        }
        stage('Source Build') {
            steps {
                git branch: 'main', url: "${env.SOURCE_GITHUB_URL}"
                script {
                    if (isUnix()) {
                        sh 'chmod +x ./back_end_soruce/gradlew'
                        sh './back_end_soruce/gradlew -p back_end_soruce clean build -x test'
                    } else {
                        bat '.\\back_end_soruce\\gradlew.bat -p back_end_soruce clean build -x test'
                    }
                }
            }
        }
        stage('Container Build and Push') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'DOCKERHUB_PASSWORD', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        if (isUnix()) {
                            dir('back_end_soruce'){
                            sh "docker build -t ${DOCKER_USER}/cal_mate_back:${currentBuild.number} ."
                            sh "docker build -t ${DOCKER_USER}/cal_mate_back:latest  ." }
                            sh "docker login -u ${DOCKER_USER} -p ${DOCKER_PASS}"
                            sh "docker push ${DOCKER_USER}/cal_mate_back:${currentBuild.number}"
                            sh "docker push ${DOCKER_USER}/cal_mate_back:latest"
                        } else {
                            dir('back_end_soruce'){
                            bat "docker build -t ${DOCKER_USER}/cal_mate_back:${currentBuild.number}  ."
                            bat "docker build -t ${DOCKER_USER}/cal_mate_back:latest  ." }
                            bat "docker login -u %DOCKER_USER% -p %DOCKER_PASS%"
                            bat "docker push ${DOCKER_USER}/cal_mate_back:${currentBuild.number}"
                            bat "docker push ${DOCKER_USER}/cal_mate_back:latest"
                        }
                    }
                }
            }
        }
        stage('K8S Manifest Update') {
            steps {
                // k8s-manifests 리포지토리를 main 브랜치에서 클론한다. 이때 자격 증명 github가 사용된다.
                git credentialsId: 'github',
                    url: "${env.MANIFESTS_GITHUB_URL}",
                    branch: 'main'
                
                script { 
                    withCredentials([usernamePassword(credentialsId: 'github', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]) {
                        def githubUrl = env.MANIFESTS_GITHUB_URL.replace('https://', '')
                        if (isUnix()) {
                            // Unix 시스템에서 boot-deployment.yml 파일 수정 후 commit 후 push
                            sh "sed -i '' 's/cal_mate_back:.*\$/cal_mate_back:${currentBuild.number}/g' argo_deploy/cal-mate-back-dep.yml"
                            sh "git add argo_deploy/cal-mate-back-dep.yml"
                            sh "git config --global user.name '${env.GIT_USERNAME}'"
                            sh "git config --global user.email '${env.GIT_EMAIL}'"
                            sh "git commit -m '[UPDATE] ${currentBuild.number} image versioning'"
                            // 인증 정보 포함하여 push
                            sh "git push https://${GIT_USER}:${GIT_PASS}@${githubUrl} main"
                        } else {
                            // Windows 시스템에서 boot-deployment.yml 파일 수정 후 commit 후 push
                            bat "powershell -Command \"(Get-Content argo_deploy/cal-mate-back-dep.yml) -replace 'cal_mate_back:.*', 'cal_mate_back:${currentBuild.number}' | Set-Content argo_deploy/cal-mate-back-dep.yml\""
                            bat "git add argo_deploy/cal-mate-back-dep.yml"
                            bat "git config --global user.name '${env.GIT_USERNAME}'"
                            bat "git config --global user.email '${env.GIT_EMAIL}'"
                            bat "git commit -m \"[UPDATE] ${currentBuild.number} image versioning\""
                            // Windows에서 변수 참조 방식 사용
                            bat "git push https://%GIT_USER%:%GIT_PASS%@${githubUrl} main"
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                if (isUnix()) {
                    sh 'docker logout'
                } else {
                    bat 'docker logout'
                }
            }
        }
        success {
            echo 'Pipeline succeeded!'
        }
        failure {
            echo 'Pipeline failed!'
        }
    }
}
```
---

## 📱 CI/CD 테스트

## 젠킨스 
- git hub push 이벤트(webhook)을 통해 소스 자동 빌드
- docker file 생성 및 docker Hub push
- 매니 페스트 수정 후 git hub push
<img width="1834" height="1488" alt="image" src="https://github.com/user-attachments/assets/a7a43855-cece-405d-a418-180c12eda0fe" />


## ArgoCD
- git hub repository와 연결 하여 manifest와의 싱크를 맞춰 k8s 클러스터를 생성
  <img width="1397" height="299" alt="image" src="https://github.com/user-attachments/assets/0487365f-e533-4101-91d6-286f0f51b799" />


---

## 😊 개인 회고록

**🍪 개인 회고록 - 강형규**

**이번 프로젝트에서 맡은 역할**

- 회원 관련 전반적인 기능( 회원 가입, 로그인, 정보 변경, jwt을 이용한 인증)
- 배포 (CI/ CD)
- 도커 이미지 생성, 깃허브 WEBHOOK을 이용한 JENKINS 자동 빌드 및 배포, ArgoCD를 이용한 K8S 환경 구축
- 프로젝트 구조 정의(front-end, back-end)

**잘한 점**

- 엑세스, 리프래시 토큰을 활용한 로그인 기능 구현
(리프래시 토큰을 생성 하여 엑세스 토큰의 시간을 짧게 잡아 토큰이 탈취 되더라도 피해가 제한 적)
- pina를 활용 해 로그인 정보를 전역으로 관리하여 간편하게 회원 정보를 관리 할 수 있게 됨
- axios를 전역 객체로 활용, intercepter를 활용 하여 인증 처리(JWT) 
 개발 -> 배포 환경으로 변경시 백엔드서버 접속 정보 변경시 base URL 변경만 으로 처리
- 기준 정보를 테이블화 하여 유지 보수성 향상

**아쉬운 점**

- 기획 단계에서 정확하게 방향을 잡지 않아 중간 개발 단계에서 테이블 스키마 변경 및 기능이 너무 자주 바뀜
- 컨텍스트 바운더리를 정확하게 나누지 않아 의사소통의 오류가 있어 동일한 Entity가 여러 패키지에 생성 됨
- 명확한 git 브랜치 전략을 새우지 않아 코드 병합시 이전 버전에 의해 코드가 덮어 씌워지는 현상이 있었음

**배운 점**

- git 브랜치 전략의 중요성을 배우게 됨.( 잠깐의 편리함이 추후에 더 큰 불편함 으로 오게 된다는것을 깨닳게 됨)
- 시간이 부족하다는 이유로 개발 과정을 공유하지 못해 중복 코드 , Entity가 생성 되어 테이블 변경 시 
  불편함을 겪게 됬으며 이후 에는 시간이 부족 하더라도 중간 중간 공유하는 시간을 가질 예정.
- git webhook, jenkins, argoCD 와 같은 빌드,배포 툴을 이용한 자동 CI/CD 구축의 편리함을 배우게 됨

**다음 프로젝트에 적용하고 싶은 점**

- DDD 설계시 시간이 부족하다는 이유로 적당히 진행 하고 명확한 바운더리를 나누지 않아 변경도 많고 중복 코드가 생기게 됬으며
  다음 프로젝트에서는 설계 단계부터 철저히 진행 할 예정.
- git 브랜치 전략을 명확하게 하여 브랜치가 꼬이지 않게 대비 할 예졍.
- 공통으로 사용할 테이블, 모듈 등을 미리 설계 및 개발 하여 모든 팀원이 같이 사용 할 수 있도록 할 예정.(중복 코드 생성 방지)

---

**🍪 개인 회고록 - 김윤지**

**이번 프로젝트에서 맡은 역할**

- 일기 기능
  - 일기 작성 / 수정 / 삭제 구현
  - 일기 작성 시 포인트 자동 지급 로직 개발
  - 일기 이미지/파일 업로드, 수정, 삭제 처리
  
- 문의사항 기능
  - 문의사항 작성 / 수정 / 삭제 기능 구현
  - 관리자 ↔ 회원 간 문의 연동 구조 설계
  - 문의 상세 조회, 상태 변경 등 전체 흐름 개발

- 캘린더 기능
  - 식단 / 운동 / 일기 전부 작성 완료 시 뱃지 부여 기능 구현
  - 하루 단위 기록을 캘린더에 반영해 상태 표시
  - 월 단위 캘린더 조회·정렬 구조 개발
  - 해당 기능들이 서로 영향을 주지 않도록 데이터 흐름 정리

**잘한 점**

- 기능별 흐름을 명확하게 설계
  캘린더가 서로 연결되는 구조여서 복잡할 수 있었지만, 역할을 명확하게 분리해 설계해서 기능들이 충돌 없이 자연스럽게 동작하도록 만들었다.

- 파일 업로드와 포인트 지급 같은 복합 로직 구현
  일기 작성 시 파일 업로드와 포인트 지급이 동시에 처리되는 로직이 까다로웠지만
  multipart 처리, 파일 경로 관리, DB 연동을 확실히 이해하며 구현할 수 있었다.

- 캘린더 자동 배지 부여 기능 구축
  하루 동안 식단·운동·일기가 모두 작성되면 자동으로 배지를 부여하도록 구현함으로써
  사용자 행동을 자연스럽게 유도하는 기능을 완성했다.
  여러 기능의 결과를 캘린더가 종합적으로 판단해야 하는 구조였기 때문에
  데이터 흐름을 정리하는 경험이 크게 도움이 되었다.

**아쉬운 점**

- 기획 변경으로 인한 반복 작업
  캘린더 기능은 식단, 운동, 일기가 서로 얽혀 있어서 기획이 수정될 때마다 여러 부분을 반복적으로 손봐야 했다.
  초기 요구사항이 조금 더 명확했다면 작업 효율이 훨씬 높았을 것 같다.

**배운 점**

- 파일 처리·상태 관리 경험
  파일 업로드, 삭제, rename, DB 연동까지 직접 구현하면서 파일 시스템과 백엔드 구조를 더 깊게 이해할 수 있었다.
  
- 기능 간 연동 설계의 중요성
  - 일기 → 캘린더 포인트
  - 식단·운동·일기 → 배지 부여
  - 문의사항 → 관리자/회원 연동 <br>
이런 식으로 기능들이 서로 연결되어 있을 때 초기 설계가 얼마나 중요한지 다시 한 번 느꼈다.

- GitHub 관리의 효과
브랜치 규칙과 이슈·PR 템플릿을 적용하면서 협업의 기준을 만들고 흐름을 체계화하는 것이 얼마나 중요한지 확실히 체감했다.

**다음 프로젝트에 적용하고 싶은 점**

- 초기 기획 단계에서 더 깊이 참여하기
  이번 프로젝트에서는 일기와 캘린더 기능이 서로 연결되는 구조였기 때문에, 기획이 바뀌면 여러 기능을 동시에 수정해야 하는 어려움이 있었다.
  다음에는 요구사항을 더 구체적으로 정리하고, 기능 간 연관 관계를 기획 단계에서 충분히 논의해 중복 작업이나 전체 구조 변경을 줄이고 싶다.

- 데이터 흐름을 미리 구조화하기
  기능들이 이어지는 흐름을 초반에 명확히 그려두면 중간에 로직을 뒤집거나 재설계할 일이 크게 줄어든다는 걸 깨달았다.
  다음 프로젝트에서는 ERD, 흐름도, 데이터 관계를 개발 전부터 더 세밀하게 잡아두는 방식으로 진행하고 싶다.

 - 파일 업로드·상태 처리 구조 표준화
   프로젝트 중반에 파일 처리 방식이 몇 번 수정되면서 코드를 다시 손보는 일이 꽤 있었다.
   다음에는 파일 업로드/삭제/이름 변경 로직을 표준 모듈처럼 미리 정해두고, 일관된 방식으로 적용해 유지보수를 더 쉽게 하고 싶다.

- 테스트 환경을 더 잘 마련하기
  일기와 캘린더는 서로 영향을 주는 기능이라 작은 수정이 다른 기능에 영향을 줄 때가 있었다.
  다음 프로젝트에서는 간단한 수준이라도 API 테스트 코드나 시나리오 테스트를 준비해 수정 시 안정성을 더 높이고 싶다.

---

**🍪 개인 회고록 - 남우경**

**이번 프로젝트에서 맡은 역할**

- 커뮤니티 관련 전반적인 기능, 페이지 구현
- 신고를 통한 게시글 및 댓글 삭제 처리 기능 

**잘한 점**

- DB설계를 세부적으로 작성하여 기능 구현 시 DB를 수정하는 일이 많지 않았음
- 기간이 짧았음에도 불구하고 커뮤니티 관련 기능들을 대부분 구현하여 웹사이트의 실효성을 높임

**아쉬운 점**

- 깃의 브랜치, 이슈, PR의 Rule을 제대로 지키지 못하고 개발한 것이 아쉬웠음
- 모달과 세부 기능들을 하나의 뷰파일에 작성하여 긴 코드가 되어 추후에 유지보수 문제가 될 가능성이 있음
- 회원 닉네임 옆에 프로필 사진을 추가하지 못해 아쉬움이 있음

**배운 점**

- 협업 환경에서 깃의 규칙 및 소통이 중요하다는 것을 깨달음
- 짧은 기간에 프론트와 백엔드 기능을 구현하여 개발에 대해 자신감을 얻을 수 있었음
- 게시판 관련된 기능들을 개발하면서 구현 경험을 쌓을 수 있었음

**다음 프로젝트에 적용하고 싶은 점**

- 팀원들과 깃의 규칙을 명확히 세워 코드가 없어지는 오류가 나지 않도록 할것임
- 단순한 개발 기능 말고도 S3, 웹소켓, AI 활용 등 다양한 기술들을 적용하여 개발하고 싶음
---

**🍪 개인 회고록 - 백준승**

**이번 프로젝트에서 맡은 역할**

- 프론트엔드 구현
    - AI 식단 추천 페이지
    - AI 운동 추천 페이지
      
- 백엔드 구현
    - AI 식단 추천 프론트엔드 - 백엔드 기능 구현
    - AI 운동 추천 프론트엔드 - 백엔드 기능 구현
    - LANGCHAIN을 활용해 식약처 데이터파일을 RAG로 갖는 식단 추천 LLM 개발
    - GPT API를 활용한 운동 추천 LLM 개발
    - FAST API를 활용한 백엔드 - LLM 통신 기능 구현
  
- 가상화
    - LLM 사용에 필요한 가상 환경(Docker image) 구현과 Kubernetes 활용

**잘한 점**

- 프론트와 백엔드 간 소통을 통한 AI 식단, 운동 추천 페이지의 전반적인 기능 구현
- 식단 추출 LLM 같은 새로운 기술을 스스로 학습을 통해 구현 성공
- LLM 제작 시 RAG를 활용해 API만 사용했을 때 발생할 수 있는 환각 문제와 학습 한계를 극복하고자 노력
- FAST API를 활용한 타 언어간 통신 환경 구축과 가상 환경 구현 성공

**아쉬운 점**

- 기능 구현 후반부에 있어 log 활용이 부족해 오류 발생 시 문제점 파악이 완벽하지 못했음.
- 구현 과정에서 사용자 직군 별 식단 차이점 같은 실서비스적 면모 파악이 부족했음.
- 일부 코드에서 요청에 대한 응답을 받는 부분이 세심하지 못했음.

**배운 점**

- 실서비스 수준의 기술을 개발하려면 기획 단계에서 정말 많은 생각을 해야한다는 점을 느꼈고 최종 프로젝트에선 이 점을 보완하고자 함.
- 촉박한 시간 속에서 개발 시 협업 툴과 사용 전략이 얼마나 중요한지 느꼈음.
- 새로운 기술을 짧은 시간에 학습하고 적용하는 귀중한 경험을 가져갈 수 있었음.

**다음 프로젝트에 적용하고 싶은 점**

- 초기 기획 단계에 더 집중해 효과적인 협업 툴 사용 전략을 수립하고 프로젝트를 진행하고자 함.
- 프로젝트 초기 회의 과정에서 구현할 기능에 대해 꼼꼼하게 회의를 진행해 실서비스적 측면에서 기능의 효용성을 더 높이고자 함.
- 단위 테스트 작성과 로그 작성, 응답 작성 등 기초적인 구현 부분을 꼼꼼하게 챙겨 프로젝트를 진행하고자 함.

---

**🍪 개인 회고록 - 이재근**

**이번 프로젝트에서 맡은 역할**

- 프론트엔드 구현
    - 식단관리 작성 / 수정 / 삭제, 조회 페이지
    - 운동관리 작성 / 수정 / 삭제, 조회 페이지
    - 로그인 페이지
    - 신고 상세 조회 모달
- 백엔드 구현
    - 식단관리 작성 / 수정 / 삭제, 조회 등 기능 전반 구현
    - 운동기록 작성 / 수정 / 삭제, 조회 등 기능 전반 구현
    - 신고 생성 / 처리 / 조회 / 삭제 등 기능 전반 구현

**잘한 점**

- 화면을 세분화해 컴포넌트 단위로 설계·구현하면서 코드 재사용성과 구조적 일관성을 높일 수 있었고, 화면의 큰 구조마다 Vue 폴더를 구분해 전체 구조를 더 명확하게 정리할 수 있었다.
- 백엔드 API를 역할별로 잘 나눠 구현해 흐름이 깔끔해지고 관리가 쉬워졌다.
- GitHub 이슈를 꾸준히 관리하며 작업 흐름을 정돈해, 개발 과정 전반을 안정적으로 이어갈 수 있었다.

**아쉬운 점**

- 초기 기획 단계에서 요구사항이 명확히 정리되지 않아, 개발 도중 기능이 자주 변경되면서 작업 흐름이 다소 흔들렸던 점이 아쉽다.
- 작업 우선순위를 더 명확히 정했으면 중복 작업이나 재작업을 줄일 수 있었을 것 같다.

**배운 점**

- GitHub 이슈·브랜치·PR을 체계적으로 관리하는 것이 협업 효율을 크게 좌우한다는 것을 확실히 느꼈다.
- 초기 기획과 구조 설계를 충분히 해두면 개발 속도와 품질이 모두 올라간다는 것을 배웠다.


**다음 프로젝트에 적용하고 싶은 점**

- AI 파인튜닝 적용해보기
    - 단순 API 호출이 아닌, 서비스에 최적화된 LLM을 직접 파인튜닝해 기능 품질을 높이고 싶음.
      모델 학습·배포·연동까지 전 과정을 경험하며 추천·분류 기능을 더욱 정밀하게 만들고자 함.
- WebSocket 기반 화상 기능 구현
    - WebRTC + WebSocket을 활용해 실시간 화상·음성 기능을 직접 구현해보고 싶음.
      시그널링 서버 구성, 연결 안정성 확보, UI 동기화까지 전체 구조를 이해하며 실시간 서비스 역량을 강화하고자 함.

---

**🍪 개인 회고록 - 이현수**

**이번 프로젝트에서 맡은 역할**

- 프론트엔드 구현
    - 포인트 & 보상 페이지 구현
    - 뽑기 이벤트 페이지 구현
    - 빙고 이벤트 페이지 구현
    - 가챠 실시간 상태 반영을 위한 WebSocket 연동
- 백엔드 구현
    - 인증, 포인트, 이벤트(Bingo/Gacha) 도메인 설계
    - Bingo 보드 생성 / 셀 인증 / 라인 포인트 지급 로직
    - Gacha 이벤트 생성 / 확률 추첨 / 공용 보드 / 보드 리셋 정책

**잘한 점**

- Vue 컴포넌트를 단순 UI가 아닌 모듈 단위로 재사용성 있게 구성
- Bingo/Gacha 같은 복잡한 로직을 도메인 기반으로 깔끔히 분리하고 예외 처리까지 적용
- 포스트맨, 로그 분석, CORS, 포트 충돌 등 다양한 에러 해결 능력이 크게 향상

**아쉬운 점**

- 도메인 변경이 많다 보니 중간에 프론트와 백엔드가 sync가 잠시 어긋나는 이슈 발생
- WebSocket, 파일 업로드 등 일부 기능은 검증 시간이 더 필요했음
- 프로젝트 후반에 테스트 코드 작성 시간이 부족해 로직 검증을 수동으로 진행한 아쉬움

**배운 점**

- WebSocket, CORS, 쿠키·세션 기반 인증 등 프론트-백엔드 연결에 대한 깊은 이해
- Bingo/Gacha 같은 이벤트성 기능은 “상태변경 기반 도메인 설계”가 중요하다는 점
- 프론트엔드에서 로직이 복잡해질수록 시스템 흐름, API 구조, 응답 패턴에 큰 영향을 준다는 것을 직접 깨달음

**다음 프로젝트에 적용하고 싶은 점**

- 프론트엔드 설계 단계에서 데이터 흐름을 먼저 확정하기
    - 이번에 경험한 것처럼 프론트 로직이 복잡해지면 백엔드, API 구조, 데이터 모델링까지 연쇄적으로 영향을 주기 때문에
      다음 프로젝트에서는 상태 흐름도와 API 명세서를 먼저 확정하는 방식을 적용하고 싶다.
- 도메인 기반 설계(DDD) 관점 유지
    - Bingo·Gacha처럼 상태 변화가 많은 기능은 도메인 단위로 분리해야 유지보수가 수월하다는 것을 깨달았다.
      다음 프로젝트에서도 초기부터 도메인을 명확히 나누고 책임 범위를 세밀하게 정해 개발하고 싶다.
- 파일 업로드 · WebSocket · 인증 구조 같은 공통 기능을 모듈화
    - 이번에는 기능별로 개별 구현하다 보니 중복이 생겼다.
      다음에는 이런 부분을 공용 모듈로 묶어서 재사용 가능한 구조로 개선하고 싶다.


